# 1. 操作系统基础

## 1.1 操作系统的概念

操作系统（OS）是一种软件，它是计算机系统中的核心组件之一，用于管理计算机硬件和软件资源，并为其他应用程序提供服务。它可以看作是计算机系统与用户之间的中介，帮助用户与计算机交互。

## 1.2操作系统的主要任务

1.**管理硬件资源**：操作系统可以管理计算机系统中的各种硬件资源，例如**CPU、内存、硬盘、网络**等，并为应用程序提供接口，使得应用程序可以访问这些资源。

2.**管理文件系统**：操作系统可以管理计算机系统中的文件系统，包括创建、删除、复制和移动文件等操作。

3.**管理进程和线程**：操作系统可以管理计算机系统中的进程和线程，包括进程的**创建、调度、挂起和终止**等操作，以及**线程的管理和调度**。**进程是一个程序执行的过程。执行前需要将该程序放到内存中，才能被cpu处理。**

4.**提供安全性**：操作系统可以提供计算机系统的安全性，例如用户认证、访问控制、加密等功能。

5.**提供接口**：操作系统可以为应用程序提供接口，使得应用程序可以访问计算机系统中的各种资源，例如文件、网络等。

总的来说，操作系统是计算机系统中最基本和最重要的软件之一，它管理和协调计算机系统中的各种资源，为其他应用程序提供服务，并提供一个良好的用户接口。

## 1.3 操作系统提供的功能

**命令接口**(Command-Line Interface，CLI)是用户与操作系统交互的主要方式之一，用户可以通过命令接口来执行文件操作、系统管理、网络设置等任务。例如，Linux操作系统提供了一组命令，如ls、cd、cp、mv、rm等，使用户可以在命令行中进行文件管理。

**程序接口**（Application Programming Interface，API）是指操作系统向应用程序提供的一组函数或系统调用，应用程序可以使用这些接口来请求操作系统的服务或执行系统操作。

## 1.4 操作系统的特征

### 1.4.1 并发

并发：并发是指同时执行多个任务，但是这些任务并不一定是同时执行的。在并发系统中，处理器会轮流执行不同的任务，每个任务只分配到一小段时间片来执行。

并行：指同时执行多个任务，这些任务在同一时刻执行。在并行系统中，有多个处理器或者多个核心同时执行多个任务。

### 1.4.2 共享

一般互斥共享和同时共享。

**互斥共享**：是指同一时间只有一个进程可以访问共享资源，其他进程需要等待资源的释放才能访问。互斥共享通常使用信号量（Semaphore）来实现，通过P操作和V操作来对资源进行加锁和解锁。互斥共享的典型例子是文件系统中的文件访问，当一个进程正在访问某个文件时，其他进程需要等待该文件的释放才能访问。

```java
package com.zyf.demo;

import java.util.concurrent.Semaphore;

/**
 * @author:zhouyangfan
 * @date:2023/3/24
 * @Description:
 **/
public class SemaphoreExample {

    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2);
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(new Worker(semaphore));
            thread.start();
        }
    }

    static class Worker implements Runnable {

        private Semaphore semaphore;

        public Worker(Semaphore semaphore) {
            this.semaphore = semaphore;
        }

        @Override
        public void run() {
            try {
                semaphore.acquire();
                System.out.println("线程" + Thread.currentThread().getName() + "获得了信号量");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                semaphore.release();
                System.out.println("线程" + Thread.currentThread().getName() + "释放了信号量");
            }
        }
    }
}
```

**同时共享**：指多个进程可以同时访问共享资源，而不会互相影响。同时共享通常使用互斥锁（Mutex）来实现，互斥锁可以保证多个进程同时访问共享资源时不会发生冲突。同时共享的典型例子是数据库系统中的数据库访问，多个进程可以同时对数据库进行读取和修改操作，而不会发生冲突。

```java
package com.zyf.demo;

/**
 * @author:zhouyangfan
 * @date:2023/3/24
 * @Description:
 **/
public class MutexExample {
    private static int count = 0;

     static final Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 5; i++) {
                    synchronized (lock) {
                        count++;
                        System.out.println(count);
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        });

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 5; i++) {
                    synchronized (lock) {
                        count++;
                        System.out.println(count);
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

互斥共享和同时共享各有优缺点，需要根据具体的应用场景来选择合适的方式。**互斥共享可以保证资源访问的正确性和安全性，但可能会引入等待时间和性能损失。同时共享可以提高系统的并发性和性能，但需要考虑数据一致性和冲突处理。**操作系统需要根据具体的需求和资源特性，综合考虑互斥共享和同时共享的利弊，选择合适的共享方式来实现资源的共享。

### 1.4.3 虚拟

<img src="C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230324192415333.png" alt="image-20230324192415333" style="zoom:50%;" />

**空分复用技术**是通过将计算机内存或磁盘等资源划分为多个不重叠的区域，每个区域分配给一个进程或任务使用，从而实现资源的共享。

<img src="C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230324192451571.png" alt="image-20230324192451571" style="zoom: 67%;" />

**时分复用技术**：通过在有限的时间内，让多个进程或任务轮流使用CPU或其他资源，从而实现多任务并发执行的能力。

<img src="C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230325132136718.png" alt="image-20230325132136718" style="zoom:50%;" />

### 1.4.4 异步

- 多任务处理：异步执行机制允许操作系统同时执行多个任务，每个任务都是独立的，并且可以在不同的时间执行。
- 时间片轮转：为了使多个任务都能够得到充分的执行时间，操作系统会为每个任务分配一个时间片，在每个时间片内执行一部分任务，然后切换到下一个任务。这样，每个任务都有机会得到执行，而且执行时间是公平的。
- 任务切换：由于每个任务的执行时间是不确定的，操作系统需要不断地进行任务切换，从而实现多任务的并发执行。在任务切换过程中，操作系统需要保存和恢复任务的上下文信息，保证任务能够从之前的执行状态继续执行。
- 调度程序：操作系统需要一个调度程序来管理多个任务的执行顺序和时间片分配，调度程序根据任务的优先级和实时性要求，动态地调整任务的执行顺序，从而保证系统的响应能力和资源利用率。
- 异步通信：在异步执行的过程中，任务之间需要进行通信和同步，操作系统提供了各种异步通信机制，如信号量、消息队列等，使得任务之间能够相互协作和同步执行。

并发和共享互相存在条件。

没有并发和共享就没有虚拟和异步。



# 2.  操作系统的发展

![97cd472fe20551075cb652c1431390a](C:\Users\ZHOUYA~1\AppData\Local\Temp\WeChat Files\97cd472fe20551075cb652c1431390a.jpg)

# 3. 操作系统的运行机制

## 3.1 指令与代码

指令（instruction）是计算机中的最小命令单元，是CPU可以执行的一条计算机指令。指令通常包含一个操作码（opcode）和一个或多个操作数（operand），操作码指定要执行的操作类型，操作数指定要操作的数据。例如，在x86 CPU中，ADD指令的操作码是0x01，它的操作数可以是寄存器、内存地址或立即数。

代码（code）是一段用来实现某种功能的程序或脚本，它通常包含多条指令和相关的数据结构和算法。代码可以是源代码或者机器代码，源代码是开发人员编写的高级语言程序，需要经过编译或解释器翻译成机器代码才能在计算机上运行，而机器代码是计算机CPU直接可以执行的二进制指令。

因此，指令是计算机的最小命令单元，而代码则是由多条指令和其他相关内容组成的实现某种功能的程序。指令是代码的一部分，指令的顺序和参数等决定了代码的功能和执行过程。

### 3.1.1 特权指令

特权指令是操作系统内核使用的一种机制，它们可以访问操作系统的核心数据结构和硬件设备。因此，普通用户程序不能直接执行特权指令，必须通过操作系统提供的接口来访问特权指令的功能。例如，操作系统中的进程调度、内存管理、设备管理等都需要使用特权指令来完成。

### 3.1.2 非特权指令

非特权指令是应用程序可以直接执行的指令，它们只能访问用户空间的数据和硬件设备。应用程序通常只需要使用非特权指令来完成各种任务，例如计算、文件操作、网络通信等等。这样设计可以提高系统的安全性和稳定性，避免应用程序对操作系统造成不必要的影响。

### 3.1.3 cpu如何判断当前是否可以执行特权指令

寄存器：是计算机中一种用于暂时存储数据的硬件组件，它们通常被嵌入在CPU中。寄存器可以高速读写，读写速度通常比内存更快，因此被广泛地用于加速计算机的运行速度。总的来说，寄存器是计算机中的一种用于存储临时数据和控制CPU状态的硬件组件。



在CPU的设计中，通常会为不同的指令集合定义不同的特权级别。CPU的操作模式通常包括至少两种模式：**用户模式（user mode）**和**内核模式（kernel mode）**，也称为特权模式（privileged mode）。

在用户模式下，CPU只能执行非特权指令，无法访问系统资源和执行特权操作。而在内核模式下，CPU可以执行所有指令，包括特权指令和非特权指令，可以访问系统资源和执行特权操作。

当CPU从用户模式切换到内核模式时，操作系统会将特权指令的执行权限交给CPU，这时CPU可以执行特权指令。而当CPU从内核模式切换回用户模式时，操作系统会将特权指令的执行权限收回，CPU再次只能执行非特权指令。

在现代的CPU中，通常使用特殊的**寄存器**来记录当前的操作模式和特权级别。例如，在x86架构的CPU中，CR0寄存器的第0位控制当前的保护模式，如果该位为1，则表示CPU处于保护模式下，可以执行特权指令。而CR4寄存器的第18位控制当前是否开启分页模式，如果该位为1，则表示CPU处于分页模式下，可以使用特权指令访问页表等数据结构。

## 3.2 两种程序

### 3.2.1 内核程序

内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。

### 3.2.2 应用程序

为了保证系统的能安全运行，普通应用程序只能再行非特权的指令，运行在用户态。

## 3.3 操作系统内核

### 3.3.1 内核

- 内核时计算机配置的底层软件，是操作系统最基本、最核心的部分。

- 实现操作系统内核功能的那些程序就是内核程序。

  ![image-20230325142107780](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230325142107780.png)



时钟管理、中断处理和原语是操作系统中的三个重要组成部分。

时钟管理是指操作系统如何使用计算机的硬件时钟来控制进程的运行。在一个多任务操作系统中，操作系统必须确保不同的进程按照一定的时间片轮流运行，以保证所有进程都能得到充分的CPU时间。时钟管理还包括操作系统如何调度进程、如何处理进程的状态转换等问题。

中断处理是指当计算机硬件发生某些事件时，如输入输出、内存访问错误等，计算机会向操作系统发送一个中断信号，请求操作系统处理该事件。中断处理程序是由操作系统编写的一段代码，当操作系统收到中断信号时，它会暂停正在执行的进程，跳转到中断处理程序来处理中断事件。中断处理程序的任务是保存现场、处理中断事件、恢复现场、重新开始执行被中断的进程。

原语是操作系统提供给应用程序的一组原始、原子的操作，具有不可分割、排他性、完整性和原子性等特点。原语可以实现操作系统的同步、互斥、通信等功能，包括进程间通信、信号量、互斥锁、条件变量等。原语通常是操作系统提供给应用程序的接口，应用程序可以使用原语来保证多个进程之间的同步和互斥，从而避免出现死锁、竞态等问题。

时钟管理、中断处理和原语是操作系统中的重要组成部分，它们分别实现了操作系统的进程调度、事件处理和同步机制。通过这三个组成部分，操作系统可以保证计算机资源的合理利用，同时保证系统的安全、可靠和稳定。

### 3.3.2 非内核

非内核代码则是运行在用户空间的应用程序和服务程序，它们无法直接访问和操作硬件设备，必须通过内核提供的系统调用接口访问系统资源。

### 3.3.3 大内核与微内核

**大内核是一种把所有操作系统核心功能都放在内核空间的设计架构。大内核的内核空间包含了所有系统资源和服务，例如进程管理、内存管理、设备驱动程序等，这些功能都由内核直接提供。**这种设计的好处是简单高效，因为所有操作都在内核空间中进行，所以系统调用和内核与应用程序的交互非常快速。但是，大内核的缺点是代码复杂度高、容错能力低、可扩展性差，一个模块出现问题可能会导致整个系统崩溃。

**微内核则是一种把操作系统核心功能分为多个小的、相对独立的模块，只保留一些最基本的操作系统服务和资源在内核空间，而其他的功能则在用户空间中实现。**微内核的设计原则是尽可能将内核的复杂度降到最低，让内核只处理最基本的任务，把其他任务委托给用户空间中的服务来处理。这种设计的好处是系统的可维护性强、可扩展性好、容错能力高，因为系统的模块相对独立，一个模块出现问题不会影响其他模块的运行。但是，微内核的缺点是系统调用和内核与应用程序的交互需要通过进程间通信(IPC)来实现，这会导致一些性能上的开销。

因此，大内核和微内核的设计有各自的优缺点。实际上，现代操作系统的内核设计往往是大内核和微内核的混合体，取两者之长，弥补各自的不足，以提供更好的性能、可靠性、安全性和可维护性。

![image-20230325142130619](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230325142130619.png)

# 4. 中断

## 4.1 中断的概念和作用

中断（Interrupt）是指计算机执行程序时，由硬件或软件发起的一种机制，用于中断正在执行的程序，将控制权转移到另一个程序或处理程序中。操作系统使用中断来处理各种事件，包括输入/输出操作、内存错误、时钟中断等。发生中断就意味着需要操作系统介入，开展管理工作。有了中断，才能实现多道程序并发执行。

操作系统的中断机制通常包括以下几个步骤：

1. 中断请求：当外部设备或程序需要操作系统处理事件时，会向操作系统发送中断请求。中断请求通常通过硬件方式，如时钟中断、设备控制器发出的中断信号等。
2. 中断处理程序：操作系统接收到中断请求后，会根据中断类型和中断源，选择相应的中断处理程序来处理中断请求。中断处理程序负责完成特定的中断处理任务，如读写设备数据、处理异常情况等。
3. 保存现场：在执行中断处理程序前，操作系统需要保存当前正在运行程序的现场，包括程**序计数器、寄存器、栈指针**等信息，以便中断处理程序执行完毕后能够正确地返回到原来的程序中继续执行。
4. 执行中断处理程序：操作系统会根据**中断类型和中断源**选择相应的中断处理程序来执行，完成相应的中断处理任务。
5. 恢复现场：当中断处理程序执行完成后，操作系统需要将之前保存的程序现场信息恢复，以便原来的程序能够继续执行。
6. 返回到原程序：操作系统将控制权返回给原来的程序，让它继续执行。

注：

- 中断发生后，CPU立即进入核心态。
- 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。
- 对于不同的中断信号，会进入不同的处理。
- 用户态到核心态是通过中断实现的。并且是唯一途径。

## 4.2 中断的分类

### 4.2.1 内中断（异常、例外、陷入）

CPU内部与当前执行的指令有关。

**内中断**通常是由当前执行的程序中的指令所引发的中断，例如执行了一条非法指令或者发生了除零错误等。这些错误会导致程序终止并通知操作系统处理。因此，内中断是由CPU内部引起的，通常由CPU内部的硬件检测到，并且不需要外部设备的干预。内中断的处理通常是由操作系统完成的。

#### 4.2.1.1 自愿中断（指令中断）

自愿中断是指由正在执行的程序或进程发出的中断请求，通常是因为程序需要等待某些事件发生，或者因为程序需要执行某些额外的操作。在内中断中的自愿中断指的是一个正在执行的程序或进程，由于某些原因，发出了中断请求，以便程序或进程可以暂停执行，并让CPU执行其他程序或进程。这种自愿中断通常与计算机系统中的多任务处理有关。

#### 4.2.1.2 强迫中断

**硬件故障：如缺页**

缺页中断是一种在虚拟内存系统中发生的中断。虚拟内存是一种计算机内存管理技术，它将虚拟内存地址映射到物理内存地址，从而允许更大的程序在内存中运行。

当一个程序试图访问虚拟内存中的某个页面（页）时，如果该页面尚未被载入物理内存，则会发生缺页中断。此时，操作系统会将缺失的页面从磁盘加载到物理内存，并重新执行被中断的指令。这个过程可能会导致延迟，因为需要从磁盘读取数据并将其复制到物理内存中。

**软件中断：整数除0**

### 4.2.2 外中断（狭义中断）

CPU外部与当前执行的指令无关。

外中断则是由外部设备引起的中断，例如键盘、鼠标、硬盘等设备。这些设备向CPU发送中断信号，以请求处理器的服务。当CPU接收到外部设备的中断信号时，它会停止当前正在执行的程序，并跳转到中断处理程序中去处理中断。通常情况下，外中断的处理需要外部设备的干预，并由操作系统和设备共同完成。

## 4.3 外中断的处理过程

![2251160d7c740801ac01426392a64ba](C:\Users\ZHOUYA~1\AppData\Local\Temp\WeChat Files\2251160d7c740801ac01426392a64ba.jpg)

# 5. 系统调用

- 程序接口（API 允许用户通过程序间接使用）：由一组系统调用组成。
- 系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的额特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。
- 操作系统提供“系统调用”功能，用户进程想要使用共享资源，**只能通过系统调用向操作系统发出请求**。操作系统会对各个请求进行协调管理，这样可以保证系统的稳定性和安全性，防止用户的非法操作。
- 系统调用会使处理器从用户态进入核心态，系统调用的相关处理在核心态中完成。

## 5.1 系统调用功能

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

## 5.2 系统调用与函数库区别

- 系统调用使操作系统向上层提供的接口。
- 有的函数库是对系统调用的进一步封装。
- 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。

| 普通程序 | 可以直接进行系统调用，也可以使用函数库。 |
| -------- | ---------------------------------------- |
| 编程语言 | 向上提供函数库。将系统调用封装成库函数   |
| 操作系统 | 向上提供系统调用                         |
| 裸机     |                                          |

不涉及系统调用的库函数：取绝对值

涉及系统调用的库函数：创建文件

## 5.3 系统调用过程

系统调用的基本过程：

1. 用户程序通过库函数或指令发起系统调用，例如调用文件操作函数open()。
2. 库函数将系统调用号和参数打包成指定的格式，执行陷入指令（软中断），并将控制权转移到操作系统内核态。
3. 操作系统内核态接收到请求后，会根据系统调用号和参数进行相应的处理，例如打开文件并返回文件描述符。
4. 操作系统将结果返回给用户程序，通常是通过寄存器或栈传递参数。
5. 用户程序接收到结果后，继续执行下一条指令。

需要注意的是，系统调用（系统调用发生在用户态，对系统调用的处理发生在核心态）过程中需要进行上下文切换，即从用户态切换到内核态，这会引入一定的开销。此外，系统调用也需要进行安全检查和错误处理，以确保系统稳定性和安全性。

![38572da93c2d32046d5f186a2703df1](C:\Users\ZHOUYA~1\AppData\Local\Temp\WeChat Files\38572da93c2d32046d5f186a2703df1.jpg)

# 6.  进程

## 6.1 定义

​       程序的定义是指令序列

​       进程的引入是为了解决多道程序同时运行的问题，也就是在一个计算机系统中，有**多个程序**需要同时运行，而且它们之间可能会互相干扰或者需要相互协作。在没有进程的概念之前，每个程序只能依次执行，而且彼此之间没有任何隔离或者保护机制。这样会导致程序之间相互影响，甚至导致系统崩溃。

**进程是指正在执行中的一个程序，是计算机中的基本执行单元（引入线程前）。**每个进程都有自己的地址空间、堆栈、寄存器和资源，包括打开的文件、已分配的内存等。进程可以通过调用系统函数来请求操作系统为其分配资源，如打开文件、分配内存、创建子进程等。进程可以并发地运行在计算机的多个CPU核心或者在同一CPU核心的不同时间片上。**同时，操作系统会为每个进程分配一个独立的进程ID(PCB中)，用于唯一标识该进程。**进程之间是相互独立的，彼此之间不能直接访问对方的内存和资源，需要通过操作系统提供的进程间通信机制来实现数据交换和协作。

- 进程：程序的一次执行过程。
- 进程：一个程序及其数据在处理机顺序执行时所发生的活动。
- 进程：进程实体的运行过程，是系统进行资源分配和调度的一个独立单元

### 6.1.1 进程与线程的区别

进程和线程都是计算机操作系统中的基本概念，但它们在本质上有一些区别。

进程是操作系统分配资源的基本单位，是一个正在执行的程序实例。一个进程包括代码、数据、堆栈、打开的文件、信号处理器、进程间通信等资源的集合。每个进程都是独立的，它们之间不共享资源，进程之间的通信必须通过操作系统提供的进程间通信机制进行。

线程是进程中的一个执行单元，是CPU调度的基本单位。一个进程可以包含多个线程，它们共享进程的地址空间和资源，但每个线程有自己的堆栈、程序计数器和状态信息。线程之间的通信比进程间通信更为简单快捷，因为它们共享同一进程的资源。

因此，进程和线程的本质区别可以归纳为以下几点：

1. 资源分配：进程是操作系统分配资源的基本单位，它拥有独立的资源，如内存、文件、网络连接等；而线程是进程内的执行单元，共享进程的资源。
2. 通信方式：进程之间的通信需要通过操作系统提供的进程间通信机制进行；而线程之间的通信可以通过共享内存等方式进行。
3. 并发性：由于线程共享进程的资源，因此多个线程可以并发执行，提高了程序的执行效率；而由于进程拥有独立的资源，进程之间的并发执行受到限制。
4. 稳定性：一个进程崩溃通常不会影响其他进程，但会导致整个系统的稳定性受到影响；而一个线程的崩溃通常只会影响到该进程，不会影响整个系统的稳定性。

综上所述，进程和线程在资源分配、通信方式、并发性和稳定性等方面有本质的区别，选择使用哪个更加依赖于具体的应用场景和需求。

### 6.1.2 PCB进程控制块

PCB通常包括以下信息：

- 进程标识符（Process Identifier，PID）：用于唯一标识一个进程。
- 进程状态（Process State）：描述进程当前的状态，例如就绪、运行、阻塞等。
- 程序计数器（Program Counter，PC）：用于记录下一条要执行的指令的地址。
- 寄存器（Registers）：包括CPU寄存器和特殊寄存器（如堆栈指针），用于保存进程的上下文信息。
- 内存指针（Memory Pointers）：用于指向进程代码、数据和堆栈的内存地址。
- 进程优先级（Process Priority）：用于决定进程被调度的优先级，即哪个进程先执行。
- 进程所拥有的资源（Process Resources）：包括已分配的内存、打开的文件、使用的I/O设备等。
- 进程调度信息（Scheduling Information）：包括进程的调度状态，调度队列中的位置等。
- 进程时间信息（Process Timing Information）：包括进程的创建时间、运行时间、等待时间等。
- 进程通信信息（Process Communication Information）：包括与其他进程通信所需的信息，如消息队列、信号量等。
- 进程父子关系（Process Parent-Child Relationship）：用于描述进程之间的父子关系，以及进程创建和终止的相关信息。

## 6.2 组成

程序段、数据段和PCB（进程控制块）是操作系统中三个重要的概念，它们分别表示进程的代码、数据和控制信息，三个部分组合为进程实体。

1. 程序段（Code Segment）：程序段是指进程代码所在的内存区域，包括可执行指令和常量数据。程序段是只读的，操作系统只有在启动进程时才会把它从磁盘加载到内存中。当程序需要修改它的代码时，会在运行时将代码段映射到可写的内存区域中。
2. 数据段（Data Segment）：数据段是指进程使用的全局变量和静态变量所在的内存区域，它包括全局数据、静态数据和常量数据。数据段是可读可写的，进程可以在运行时修改它的值。
3. 进程控制块（Process Control Block，PCB）：PCB是操作系统用来管理进程的数据结构，它存储着进程的上下文信息，包括进程ID、进程状态、程序计数器、寄存器状态、内存指针、进程优先级、进程资源使用情况、进程调度信息、进程时间信息和进程通信信息等。操作系统通过读取和修改PCB中的信息来管理和控制进程的执行。

进程实体是静态的，进程是动态的。

## 6.3 组织方式

进程的组织方式：

- 链接方式
  1. 按照进程状态将PCB分为多个队列
  2. 操作系统持有指向各个队列的指针
- 索引方式
  1. 根据进程状态不同，建立几张索引表
  2. 操作系统持有指向各个索引表的指针

![0a1078a85b557e0551966f78ea39c84](C:\Users\ZHOUYA~1\AppData\Local\Temp\WeChat Files\0a1078a85b557e0551966f78ea39c84.jpg)

![image-20230327152729938](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230327152729938.png)



## 6.4 进程的特征

进程是计算机操作系统中的一个基本概念，表示正在执行的程序实例。进程具有以下特征：

1. 程序代码和相关数据：每个进程都包含一个程序代码和相关数据，这些数据包括变量、缓冲区、文件句柄等。
2. 进程状态：进程可以处于就绪状态、运行状态、阻塞状态等不同状态之一。就绪状态表示进程已准备好运行，但还未获得处理器时间。运行状态表示进程正在执行。阻塞状态表示进程等待某些事件的发生，例如输入输出操作完成。
3. 进程控制块（PCB）：每个进程都有一个进程控制块（PCB），用于描述进程的状态信息，包括进程的标识符、状态、程序计数器、堆栈指针、优先级等。
4. 进程间通信：进程可以通过各种通信机制（例如管道、消息队列、共享内存）与其他进程通信，共享数据和资源。
5. 资源管理：进程需要使用各种资源，如处理器时间、内存、输入输出设备等。操作系统需要对这些资源进行管理，以确保进程能够正常运行，并避免资源的浪费和冲突。
6. 调度和并发控制：操作系统需要对进程进行调度，以便在有限的资源下，实现高效的并发执行。操作系统还需要实现并发控制机制，以确保共享资源的安全和一致性。

综上所述，进程是操作系统中最基本的执行单元之一，具有状态、控制块、通信和资源管理等特征。

## 6.5 进程的状态

进程为什么会有不同的状态：

1. **因为在操作系统中，进程的执行需要消耗多种系统资源，如 CPU、内存、文件、网络等资源。不同的进程在执行过程中，由于其所需的资源状态不同，会表现出不同的状态。**例如，当一个进程需要等待某个资源的到达或者 I/O 操作的完成时，它就会进入阻塞状态，因为此时它无法继续执行。在阻塞状态下，操作系统会把该进程从 CPU 中暂停，并把其放入等待队列，直到等待的资源到达或者 I/O 操作完成后，该进程才会被唤醒并重新进入就绪状态，等待被 CPU 调度执行。
2. 进程状态的变化也是操作系统进行进程调度的基础。操作系统需要根据进程的状态和优先级，以及可用的系统资源，来进行进程调度，以保证系统资源的合理分配和高效利用。

**进程的几种状态：**

- 运行状态（Running）：占有CPU，并在CPU上运行。（单核CPU每个时刻只有一个进程正在运行）。
- 就绪状态（Ready）：就绪态是进程能够被执行的一个必要条件，只有处于就绪态的进程才能够被调度执行。在就绪态下，**进程已经完成了所有的前提条件**，例如它已经获得了所有需要的资源，如 CPU、内存、IO 等，并且等待着系统分配 CPU 来执行。**一旦系统分配了 CPU，进程就会进入运行态并开始执行。**
- 阻塞状态（Blocked）：阻塞态是指进程由于某些原因，暂时无法继续执行，需要等待某种事件的发生才能够继续执行的状态。**在阻塞态下，进程已经不能够进行任何操作，包括 CPU 的占用和对其他资源的访问。**当进程进入阻塞态时，操作系统会将其从就绪队列中移除，转而将其他处于就绪态的进程调度到 CPU 上执行，以提高系统的效率。一旦进程等待的事件发生，它就会从阻塞态转换为就绪态，等待系统调度其执行。
- 新建状态（New）：在新建状态下，进程还没有开始执行，也没有被分配到任何资源，更没有被操作系统调度执行。新建状态是进程状态的一种瞬时状态，仅仅是进程的一种中间状态，进程在被调度执行之前，一定会先经过就绪态。
- 终止状态（Terminated）：进程运行结束或产生了Bug，回收资源、撤销PCB。

### **进程状态之间的转换**

![image-20230328094931994](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328094931994.png)

**创建态->就绪态**

​        当进程被创建后，它会被分配一个唯一的进程标识符（PID），并被操作系统初始化，包括为进程分配资源和内存空间、设置进程控制块（PCB）、建立代码段、数据段、堆栈等。完成初始化后，进程会进入新建状态。在新建状态下，操作系统会将进程放入就绪队列中，等待被调度执行。当操作系统选择该进程进行调度时，进程就会从新建状态转换到就绪态。在就绪态下，进程已经准备好执行，等待操作系统为其分配 CPU 进行执行。

**就绪态->运行态**

当进程进入就绪态后，它会等待操作系统为其分配 CPU，并进行调度执行。当操作系统选择该进程并为其分配 CPU 后，进程就从就绪态转换为运行态。

**运行态->就绪态**（被动）

进程运行态到就绪态的转换是指在运行状态下的进程**被迫放弃** CPU，进入就绪态等待重新被调度执行。状态转换发生的原因：操作系统的调度算法选择了其他进程，导致此进程被迫放弃，进入了就绪态。

**运行态->阻塞态**（主动）

进程从运行态到阻塞态的转换通常是由于进程需要等待某些事件的发生，例如等待 I/O 完成、等待资源分配等，此时进程会释放 CPU 并进入阻塞态等待事件完成。进程在阻塞态下，不能执行任何指令，直到事件完成后重新进入就绪态。因此，阻塞态是进程暂时休眠的状态。

**阻塞态->就绪态**

进程从阻塞态到就绪态的转换是指进程等待的事件已经发生，操作系统将其从等待队列中移除，重新放入就绪队列中等待被调度执行。进程从阻塞态到就绪态的转换通常是由外部事件的发生触发的，是异步的。一旦进程从阻塞态到就绪态转换成功后，操作系统会重新调度该进程并为其分配 CPU 进行执行。

**运行态->终止态**

进程从运行态到终止态的转换通常是由于进程已经完成了它的任务，或者因为出现了某些错误而被强制终止。

## 6.6 进程控制

![image-20230328094914098](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328094914098.png)

### 6.6.1 进程控制定义

​           进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新的进程，撤销已有进程、实现进程状态转换等功能。

### 6.6.2 如何实现进程控制

原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。“关中断指令”和“开中断指令”的权限非常大，必然是只允许在核心态下执行的特权指令。

### 6.6.3 进程控制的相关原语

进程控制的相关原语要做的三件事：

- 更新PCB中的信息
  1. 所有的进程控制原语一定都会修改进程状态标志。
  2. 剥夺当前运行进程的CPU使用权必然需要你保存其运行环境。
  3. 某进程开始前必然要恢复其运行环境。

- 将PCB插入合适的队列
- 分配/回收资源

![image-20230328094948707](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328094948707.png)

![image-20230328102515343](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328102515343.png)

![image-20230328102710178](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328102710178.png)

![image-20230328102723369](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230328102723369.png)

## 6.7 进程通信

进程通信包括共享存储、消息传递和管道通信。

进程通信：进行之间的信息交换和传递。

### 6.7.1 共享存储

- 设置一个共享空间
- 要互斥地访问共享空间
- 两种方式：基于数据结构的共享空间和基于存储区的共享空间。

### 6.7.2 管道通信

- 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
- 各进程要互斥地访问管道。
- 数据与字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
- 如果没有写满，就不允许读。如果没读空，就不允许写。

### 6.7.3 消息传递

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

1. 直接通信方式
2. 间接通信方式

# 7. 线程

## 7.1 线程介绍

线程（Thread）是计算机科学中的一个术语，指的是进程中独立的执行流程。一个进程可以包含多个线程，每个线程可以独立执行不同的任务，但它们**共享进程的内存空间和其他系统资源**，包括文件、打开的网络连接和信号等。

**引入线程后，线程是一个基本的CPU执行单元，也是程序执行流的最小单位。而进程是资源分配的基本单位。**

线程的特性：

1. 独立性：线程是进程中的独立执行流程，每个线程都有自己的堆栈、程序计数器和寄存器，**线程之间可以独立执行不同的任务。**
2. 共享性：线程共享进程的地址空间、文件、打开的网络连接和信号等系统资源，这使得线程之间可以非常方便地交换数据和信息。
3. 轻量级：线程的创建、撤销和切换比进程更加轻量级，因此在并发编程中通常使用线程而不是进程。

## 7.2 线程的属性

- 多CUP计算中，各个线程可以占用不同的CPU。
- 每个线程都有一个线程ID，线程控制块。
- 线程也有就绪、阻塞、运行三种基本状态。
- 线程几乎不拥有系统资源。
- 同一进程的不同线程共享进程的资源
- 由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换。
- 不同进程中的线程切换，会引起进程切换。
- 切换同进程内的线程，系统开销很小。
- 切换进程，系统开销较大。

在同一个进程中的不同线程之间进行切换时，是不会导致CPU上下文的切换，因为它们共享相同的进程地址空间和系统资源。这意味着，切换线程不需要切换进程，因为它们属于同一个进程，且它们的状态信息都可以通过线程上下文来保存和恢复。

然而，当不同进程中的线程之间进行切换时，会导致CPU上下文的切换，因为它们属于不同的进程，各自有独立的地址空间和系统资源。这种切换需要将先前进程的状态信息保存到内存中，然后将另一个进程的状态信息加载到CPU中。这就是进程切换，它比线程切换开销更大，因为需要在不同的进程之间进行上下文切换和内存交换。

## 7.3 线程的实现方式

### 7.3.1 用户级线程

- 应用级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）
- 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
- 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。

### 7.3.2 内核级线程

- 内核级线程的管理工作由操作系统内核完成。
- 线程调度，切换等都由内核负责。因此，内核级线程的切换必然需要在核心态下才能完成。
- 从操作系统内核的视角能看到的线程。
- 只有内核级线程才是操作系统处理机分配的单位。



### 7.3.3 多线程模型

支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了多线程模型。

**多对一模型**

- 多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
- 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。
- 缺点：多个线程不可以在多个核心的处理机上并行运行，一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。

**一对一模型**

- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。
- 确定：线程由内核管理，管理开销大。

**多对多模型**

- 是更合理的解决方式

# 8 处理机调度![image-20230330144333841](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230330144333841.png)

## 8.1 基本概念

调度：当有一堆任务要处理，但由于资源有限，这些事没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

处理机调度：

- 处理机调度是指操作系统为多个进程分配CPU执行时间的过程。在**多道程序设计的环境下**，处理器不仅仅需要在运行的进程之间进行切换，还需要根据不同进程的特点和优先级等因素，合理地安排CPU执行时间，以提高系统的效率和吞吐量。
- 处理机调度是操作系统的重要功能之一，目的是使多个进程在合理的时间内得到CPU资源的利用，从而保证系统的高效运行。在实际中，处理机调度算法有很多种，例如先来先服务（FCFS）、短作业优先（SJF）、最高优先级调度、时间片轮转等，每种调度算法都有其适用的场景和优缺点，需要根据具体情况进行选择。

## 8.2 三个层次

**高级调度（作业调度）：**

- 操作系统的高级调度也称为**作业调度**，是指操作系统对新进入系统的进程进行决策，决定是否将其加入到可运行进程队列中。高级调度的任务是控制系统中进程的数量，以避免系统资源的过度占用和过度拥塞，保证系统的稳定性和高效性。
- 按一定原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利。
- 作业调入时会建立相应的PCB，作业调出时才撤销PCB。
- 高级调度主要指的是调入问题，因为只有调入的时机需要操作系统来决定，但调出的时机必然是作业运行结束才调出。

**中级调度（内存调度）：**

- 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存进行等待。等它重新具备了运行条件且内存又空闲时，再重新调入内存。这么做是为了提高内存利用率和系统吞吐量。
- 暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB会记录进程数据在外存中存放的位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控和管理。被挂起的进程PCB会被放到挂起队列中。
- 中级调度（内存调度）：就是要决定哪个处于挂起状态的进程重新调入内存。

**进程挂起和阻塞的区别在于进程的状态和资源占用情况。挂起的进程不占用CPU时间片和内存资源，而阻塞的进程仍然占用内存资源，但不占用CPU时间片。**

**低级调度（进程调度）：**

- 它是指操作系统根据某种算法从就绪队列中选择一个进程或线程，并分配处理器时间给它，让其运行一段时间，直到完成或被阻塞。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。

- 低级调度通常是由操作系统内核来实现的，其主要目的是优化系统的资源利用率和响应时间。它负责决定哪些进程或线程将获得处理器时间，以及处理器时间分配的顺序和时间片长度等。通常，低级调度算法会考虑各个进程或线程的优先级、等待时间、处理器利用率等因素来进行调度。

- 进程调度的频率很高，一般几十毫秒一次。

  ![image-20230330144318749](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230330144318749.png)

![image-20230330144254975](C:\Users\zhouyangfan\AppData\Roaming\Typora\typora-user-images\image-20230330144254975.png)

## 8.3 进程调度的时机

**什么时候需要进程调度？**

- 当前运行的进程主动放弃处理机
  1. 进程正常终止。
  2. 运行过程中发生异常而终止。
  3. 进程主动请求阻塞。

- 当前运行的进程被动放弃处理机
  1. 分配给进程的时间片用完。
  2. 有更紧急的事要处理。
  3. 有更高级的进程进入就绪队列。

**不能进行进程调度与切换的情况**

1. 在处理中断的过程中。
2. 进程在操作系统**内核程序临界区**中不能进行调度与切换。
3. 在原子操作过程中。

**临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。

**临界区**：访问临界资源的那段代码。

**内核程序临界区**：一般是用来访问某种内核数据结构的，比如进程的就绪队列。

内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。当一个进程进入内核程序的临界区时，操作系统通常会禁止该进程的调度和切换。这可以通过关闭抢占（preemption）机制来实现，抢占机制是操作系统用来在多任务环境下控制进程调度的一种机制。在禁止抢占的情况下，即使有更高优先级的进程就绪，也不能抢占当前运行的进程，直到当前进程完成临界区的执行。

在访问普通临界区时，操作系统可以进行进程调度，但是需要保证访问共享资源的正确性。例如打印机设备资源。

## 8.4 进程调度的方式

- 非剥夺调度方式（非抢占式）：只允许进程主动放弃处理机。在运行过程中即便有更紧急的任务到达，当前进程依然会继续使用处理机，知道该进程终止或主动要求进入阻塞态。系统开销小但无法及时处理紧急任务，适合早期的批处理系统。
- 剥夺调度方式（抢占式）：如果有一个更紧急的任务需要使用处理机，则立即停止正在执行的进程，将处理机分配给更重要更紧迫的那个进程。可以优先处理紧急任务，可以实现让各进程按时间片轮流执行的功能。适合于分时操作系统，实时操作系统。

“狭义的进程调度”与“进程切换”的区别：

- 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。
- 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
- 广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行的进程各种数据的保存。
2. 对新的进程各种数据的恢复。

进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。 

## 8.5 调度算法的评价指标

### 8.5.1 CPU利用率

CPU利用率是计算机中一个重要的性能指标，表示CPU在某一时间内被使用的程度。CPU利用率通常用百分比表示，它可以帮助我们了解计算机系统的性能瓶颈，并且可以帮助我们识别一些潜在的性能问题。

假设我们要计算某个进程在过去1秒钟内的CPU利用率，可以使用以下公式：

`CPU利用率 = (进程使用的CPU时间 / 总CPU时间) * 100%`

CPU利用率是一个瞬时指标，随着时间的推移而不断变化。

### 8.5.2 系统吞吐量

**系统吞吐量是指系统在一定时间内处理的任务数量或数据量，通常用来衡量系统的性能。**

假设我们有一个网络服务器，它可以处理客户端发送的HTTP请求。我们想要计算该服务器在过去1分钟内的HTTP请求吞吐量，可以使用以下公式：

`HTTP请求吞吐量 = 总HTTP请求量 / 统计时间`

其中，总HTTP请求量是指服务器在过去1分钟内接收到的HTTP请求总数，统计时间是指过去1分钟的时间长度。

### 8.5.3 周转时间

**周转时间（turnaround time）是指一个进程从进入系统到完成执行并退出系统的整个时间间隔，也就是从进程提交到完成的时间。周转时间是衡量系统性能和进程执行效率的重要指标之一。**

周转时间=作业在外存后备队列上等到作业调度（高级调度）的时间 + 进程在就绪队列上等待进程调度（低级调度）的时间 + 进程在CPU上执行的时间 + 进程等待I/O等操作完成的时间。

周转时间的长短取决于很多因素，包括系统负载、进程调度算法、I/O操作等。通常来说，一个进程的周转时间越短，表示它在系统中的执行效率越高，系统的性能也越好。

**进程平均周转时间（average turnaround time）是指在一定时间范围内，所有进程的周转时间的平均值，它是评估系统性能和进程执行效率的重要指标之一。**进程平均周转时间越短，表示系统性能越好，进程执行效率也越高。

计算进程平均周转时间的公式如下：

`平均周转时间 = 所有进程的周转时间之和 / 进程数量`

例如，如果在一个系统中有5个进程，它们的周转时间分别是20、30、25、15和40个时间单位，则这5个进程的平均周转时间为：

`(20 + 30 + 25 + 15 + 40) / 5 = 26`

**带权周转时间（weighted turnaround time）是指一个进程完成执行并退出系统所花费的时间，乘以该进程的权重系数（通常是进程执行的优先级），得到的结果。它是衡量进程调度算法的重要指标之一。**

计算带权周转时间的公式如下：

`带权周转时间 = （完成时间 - 到达时间）/ 实际执行时间`

**平均带权周转时间（average weighted turnaround time）是指所有进程的带权周转时间的平均值，它是评估进程调度算法性能的重要指标之一。**

计算平均带权周转时间的公式如下：

**平均带权周转时间 = 所有进程的带权周转时间之和 / 进程数量**

### 8.5.4 等待时间

**进程的等待时间指的是进程在就绪队列中等待被调度执行的时间。**也就是说，当一个进程被创建后，它需要等待CPU资源来执行。在这个等待的过程中，进程会进入就绪状态，等待操作系统的调度器将其分配给CPU执行。进程等待的时间越长，它在CPU上执行的时间就越短，因此进程等待时间长是一个不利的因素。

在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

**进程的等待时间可以用进程开始执行的时间减去进程被创建的时间来计算。**例如，假设一个进程被创建时刻是T0，进入CPU执行时刻是T1，那么该进程的等待时间为T1-T0。如果该进程在T0时刻就进入了就绪队列等待CPU，那么它的等待时间就是0。

在多道批处理系统中，为了减少进程的等待时间，通常会采用一些调度算法，例如**最短作业优先（SJF）**或者**最高响应比优先（HRRN）**等，这些算法可以帮助操作系统更好地安排进程的执行顺序，从而使得进程的等待时间尽可能地短。

### 8.5.5 响应时间

**进程的响应时间指的是从进程发出请求到系统开始响应这个请求所需要的时间。**

## 8.6 调度算法

算法思想

算法规则

算法用于作业调度还是进程调度

抢占式还是非抢占式

优点和缺点

是否会导致饥饿（某进程/作业长期得不到服务）

### 8.6.1 先来先服务（FCFS）

先来先服务（First-Come, First-Served，简称FCFS）是一种基本的进程调度算法。该算法按照进程到达的顺序将它们加入到一个先进先出的队列中，然后按照队列中的顺序依次执行进程。

### 8.6.2 短作业优先（SJF）

短作业优先（Shortest Job First，简称SJF）是一种进程调度算法，它会按照每个进程所需的CPU时间来排序并依次执行这些进程。SJF算法通常能够最大限度地减少平均等待时间，并且适用于CPU繁忙的情况。

SJF算法分为两种类型：非抢占式和抢占式。非抢占式SJF算法是指在一个进程开始执行后，不会被其他进程打断，直到它执行完毕为止。而抢占式SJF算法则允许更短的进程可以中断当前正在执行的进程，以便更快地执行。

### 8.6.3 高响应比优先（HRRN）

