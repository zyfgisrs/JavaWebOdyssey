# Redis内存淘汰策略

## Redis 数据的生存时间

- `TTL` (Time-to-live) 的定义与含义。
  - `TTL`是一个时间限制或过期时间，在此时间后，数据将被视为过期或无效。
  - 在数据库和缓存系统（如Redis）中，`TTL`可以用于设置键或数据的过期时间。一旦数据达到其`TTL`，它将自动从系统中删除或标记为过期。
- 使用 `EXPIRE` 和 `PEXPIRE` 设置生存时间。
- 使用 `TTL` 和 `PTTL` 命令查询剩余的生存时间。

## 内存淘汰策略

> 淘汰策略是当 Redis 内存使用达到 `maxmemory` 设置时，如何淘汰数据。

### 可用的内存淘汰策略

1. **volatile-lru**：
   - **策略**：使用近似的 LRU（最近最少使用）策略淘汰数据。
   - **适用对象**：只淘汰那些设置了过期时间（TTL）的键。
   - **说明**：从设置了过期时间的键中选择近期最少使用的键进行淘汰。
2. **allkeys-lru**：
   - **策略**：使用近似的 LRU 淘汰数据。
   - **适用对象**：从所有键中选择。
   - **说明**：从所有键中选择近期最少使用的键进行淘汰，不管这个键是否设置了过期时间。
3. **volatile-lfu**：
   - **策略**：使用近似的 LFU（最不经常使用）策略淘汰数据。
   - **适用对象**：只淘汰那些设置了过期时间的键。
   - **说明**：从设置了过期时间的键中选择近期使用频率最低的键进行淘汰。
4. **allkeys-lfu**：
   - **策略**：使用近似的 LFU 淘汰数据。
   - **适用对象**：从所有键中选择。
   - **说明**：从所有键中选择近期使用频率最低的键进行淘汰，不管这个键是否设置了过期时间。
5. **volatile-random**：
   - **策略**：随机淘汰数据。
   - **适用对象**：只淘汰那些设置了过期时间的键。
   - **说明**：从设置了过期时间的键中随机选择一个键进行淘汰。
6. **allkeys-random**：
   - **策略**：随机淘汰数据。
   - **适用对象**：从所有键中选择。
   - **说明**：从所有键中随机选择一个键进行淘汰，不管这个键是否设置了过期时间。
7. **volatile-ttl**：
   - **策略**：根据 TTL（Time To Live）淘汰数据。
   - **适用对象**：只淘汰那些设置了过期时间的键。
   - **说明**：从设置了过期时间的键中选择 TTL 值最小（即最快到期）的键进行淘汰。
8. **noeviction**：
   - **策略**：不进行任何淘汰操作。
   - **说明**：当内存达到上限时，Redis 不会淘汰任何键。而是在写操作上返回一个错误。

### 相关配置

以下是 Redis 内存淘汰的相关配置及其说明：

| 配置项                                             | 说明                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `maxmemory`                                        | 用于设置 Redis 最大使用的内存量。超过这个值时，根据 `maxmemory-policy` 进行数据淘汰。 |
| `maxmemory-policy`                                 | 定义当达到 `maxmemory` 时采用的淘汰策略。                    |
|                                                    | - **volatile-lru**: 使用近似 LRU 策略，只淘汰设置了 TTL 的键。 |
|                                                    | - **allkeys-lru**: 使用近似 LRU 策略，淘汰任意键。           |
|                                                    | - **volatile-lfu**: 使用近似 LFU 策略，只淘汰设置了 TTL 的键。 |
|                                                    | - **allkeys-lfu**: 使用近似 LFU 策略，淘汰任意键。           |
|                                                    | - **volatile-random**: 随机淘汰设置了 TTL 的键。             |
|                                                    | - **allkeys-random**: 随机淘汰任意键。                       |
|                                                    | - **volatile-ttl**: 淘汰即将过期的键 (设置了 TTL 且 TTL 最小的键)。 |
|                                                    | - **noeviction**: 当达到 `maxmemory` 时不淘汰任何数据，而是返回写操作错误。 |
| `maxmemory-samples`                                | 用于近似 LRU 和 LFU 淘汰策略中的样本大小。默认为 5，意味着从 5 个键中选择一个进行淘汰。 |
| `hz`                                               | 代表 Redis 主事件循环的执行频率。换句话说，它决定了 Redis server 每秒会执行多少次事件循环。一个较高的 `hz` 值意味着 Redis 可以更频繁地检查各种事件，如连接超时、到期的键等。但这也意味着会增加 CPU 使用率。默认为 10。如果你的 Redis 实例主要用于缓存，并且你希望尽可能快地释放过期的键以释放内存，你可以考虑增加 `hz` 的值。对于大部分应用，默认值 10 已经足够。 |
| `maxmemory-clients`                                | 普通/pubsub 客户端的内存用量总计。如果达到上限，系统将逐出使用最多内存的客户端。默认值为 `0%`（无限制）。可接受的值为 `0%` 到 `100%` 之间的整数百分比值。表示客户端存储空间受限的实例最大内存的百分比。 |
| `client-query-buffer-limit`                        | 每个客户端都受到一个查询缓冲区限制。这是一个不可配置的硬限制，当客户端查询缓冲区（即我们用来累积来自客户端的命令的缓冲区）达到1GB时，将关闭连接。实际上，这只是为了避免客户端或服务器软件错误导致的服务器崩溃的极端限制。 |
| `client-output-buffer-limit normal 0 0 0`          | **normal**: 这是普通的客户端类型。 第一个`0`: 硬限制。当客户端的输出缓冲区大小超过这个值时，Redis会立即断开客户端连接。`0`表示没有限制。 第二个`0`: 软限制。当客户端的输出缓冲区大小超过这个值并持续超过指定的时间（第三个参数）时，Redis会断开客户端连接。`0`表示没有限制。 第三个`0`: 软限制的时间，单位是秒。在这种情况下，因为软限制是`0`，所以这个时间参数是无关紧要的。 |
| `client-output-buffer-limit replica 256mb 64mb 60` | **replica**: 这是副本（或称为从服务器）的客户端类型。 `256mb`: 硬限制。当副本的输出缓冲区大小超过256MB时，Redis会立即断开副本的连接。 `64mb`: 软限制。当副本的输出缓冲区大小超过64MB并持续超过60秒时，Redis会断开副本的连接。 `60`: 软限制的时间，单位是秒。 |
| `client-output-buffer-limit pubsub 32mb 8mb 60`    | **pubsub**: 这是发布/订阅模式的客户端类型。 `32mb`: 硬限制。当发布/订阅客户端的输出缓冲区大小超过32MB时，Redis会立即断开客户端连接。 `8mb`: 软限制。当发布/订阅客户端的输出缓冲区大小超过8MB并持续超过60秒时，Redis会断开客户端连接。 `60`: 软限制的时间，单位是秒。 |

- 使用这些配置项，用户可以根据具体的应用场景和数据特点调整 Redis 的内存使用和淘汰策略，确保内存的有效使用和高性能。

- 如果Redis工作的环境没有大规模的数据传输，基本上走默认的环境就可以了，如果说要是有大规模的数据传输，就需要进行有效的限制，同时也要预估并发量和需要准备的服务器内存。

## LRU淘汰算法的实现

### LRU 算法

Redis中的LRU（Least Recently Used）淘汰算法用于在内存达到限制时选择并移除最近最少使用的键。简单来说，它跟踪每个键的访问情况，并在需要释放内存时优先淘汰那些最长时间未被访问的键。

### 样本式LRU简介

- 在传统的 LRU 实现中，为了确保每次都淘汰最久未使用的键，需要维护所有键的访问顺序，这在实际应用中可能会有性能问题。因此，Redis 选择了一个更加轻量级的、近似的方法来实现 LRU。
- Redis 使用样本式 LRU 作为其缓存淘汰策略，这是一个与传统 LRU 类似但更为轻量级的策略。尽管它是基于随机样本的，但在许多实际应用场景中，它的效果与真正的 LRU 非常接近。

### 样本式LRU工作原理

- 当需要淘汰一个键时，Redis 不会查找最久未使用的键，而是随机抽取一组键作为样本。
- 从这个样本中选择最久未使用的键进行淘汰。
- 默认情况下，Redis 会从 5 个键中选取一个淘汰（这是可以配置的，通过 `maxmemory-samples` 参数）。

## LFU淘汰算法的实现

### LFU算法

- Redis中的LFU（Least Frequently Used）淘汰算法是一种用于在内存不足时移除访问频率最低的键的机制。不同于LRU算法关注于“最近”的访问时间，LFU更注重键被访问的频率。
- LFU算法适合于那些频繁访问的键比较固定的场景，因为它能够有效识别出那些长时间内很少被访问的键，并将其作为淘汰的首选。与LRU相比，LFU更加关注键的长期访问模式，而非仅仅是最近的访问活动。

### Redis中LFU算法的实现

1. **计数器**：
   - Redis 为每个键维护一个访问计数器。但这个计数器不是一个简单地增加的数值，而是一个在时间窗口上逐渐递减的数值，这样能够更好地捕获数据的“近期”使用频率。
2. **计数器递增与衰减**：
   - 当一个键被访问时，其计数器增加。
   - 随着时间的推移，为了反映近期的使用模式，Redis 会定期地对计数器进行衰减。
3. **淘汰策略**：
   - 当内存达到上限时，Redis 会采取淘汰策略来为新数据腾出空间。
   - LFU 策略会从一组随机抽样的键中选取访问频率最低的键进行淘汰。
   - 抽样的大小可以通过 `maxmemory-samples` 配置参数进行调整。
4. **配置**：
   - 使用 `maxmemory-policy` 参数设置为 `volatile-lfu` 或 `allkeys-lfu` 来启用 LFU 淘汰策略。
   - `volatile-lfu`：只会淘汰设置了 TTL（Time To Live）的键。
   - `allkeys-lfu`：会淘汰所有键，无论是否设置了 TTL。
5. **为什么选择近似 LFU**：
   - 完整的 LFU 实现通常需要维护一个全局的、根据使用频率排序的数据结构，这在实践中可能会非常消耗性能和内存。
   - Redis 的近似 LFU 实现提供了一个折中的方法，它牺牲了一些准确性以获得更高的效率。

## 内存碎片整理

内存碎片是一个常见的问题，特别是在长时间运行的实例中。随着时间的推移，由于键的添加、删除和更新，内存分配可能会变得不连续，导致内存碎片。这不仅会浪费内存，还可能影响 Redis 的性能。

### 内存碎片

内存碎片是指内存中的空闲空间被分散在不同的小块中，而不是连续的一大块。这通常是由于反复的内存分配和释放操作造成的。

### 内存碎片检查

您可以使用 `info memory` 命令来查看 Redis 的内存使用情况。其中，`mem_fragmentation_ratio` 指标表示内存碎片率。如果这个值远大于 1，那么可能存在内存碎片问题。

### 相关配置

|                配置                 |                             描述                             |
| :---------------------------------: | :----------------------------------------------------------: |
|          `activedefrag no`          | 默认情况下Redis没有开启内存碎片整理，如果要想开启的话，则需要将activedefrag配置设置为yes |
| `active-defrag-ignore-bytes 100mb`  | 如果一有碎片就开始进行整理，则会带来严重的性能问题，因此需要合理配置碎片大小 |
| `active-defrag-threshold-lower 10`  |               定义碎片整理开始的最小内存占用比               |
| `active-defrag-threshold-upper 100` |                  定义碎片整理回收的百分比。                  |
|     `active-defrag-cycle-min 1`     |                      碎片整理最小占用率                      |
|    `active-defrag-cycle-max 25`     |                      碎片整理最大占用率                      |
| active-defrag-max-scan-fields 1000  | 当 Redis 进行在线碎片整理时，它会扫描其内部数据结构（例如哈希表、集合等）来查找和移动可以被整理的内存块。 配置选项限制了每次迭代中扫描的字段数量。这是为了确保碎片整理过程不会消耗太多的 CPU 时间，从而影响 Redis 的性能。 |
|       jemalloc-bg-thread yes        | `jemalloc-bg-thread` 是一个可以帮助您优化 Redis 内存使用的配置选项。在 jemalloc 的某些版本中，引入了背景线程（background threads）功能。这些线程在后台运行，负责清理和回收未使用的内存，从而减少内存碎片和提高内存使用效率。jemalloc 是 Redis 默认使用的内存分配器。它为内存分配和释放提供了高效的策略，特别是在多线程环境中。`jemalloc-bg-thread` 配置选项允许用户启用或禁用这些背景线程。 |

## 补充知识

### 主从服务器

在Redis中，我们经常听到"主服务器"（Master）和"副本"（Replica）或者在早期版本中被称为"从服务器"（Slave）的概念。

- **主服务器 (Master)**: 主服务器是可以接受写入操作的Redis实例。
- **副本 (Replica) 或 从服务器 (Slave)**: 副本是主服务器的只读复制品。它会复制主服务器的数据，确保数据的冗余和高可用性。副本主要用于分担读取负载和数据备份。在早期的Redis版本中，副本被称为"从服务器"，但在后续版本中，为了避免主-从术语的负面含义，它被更名为"副本"。

当我们在配置中看到与"replica"相关的设置时，它通常是指与副本连接的客户端的设置。这意味着这些设置是为那些与副本进行通信的连接（即从主服务器同步数据的连接）而设定的。

**发布/订阅 (Pub/Sub) 模式** 是一种消息传递模式，其中发送消息的实体（发布者）不需要知道接收消息的实体（订阅者），反之亦然。这种模式允许消息的发送者和接收者解耦，使得系统更加灵活和可扩展。

### Redis的发布/订阅系统

- **发布者 (Publisher)**: 是一个Redis客户端，它发送消息到一个或多个频道。
- **订阅者 (Subscriber)**: 是另一个Redis客户端，它订阅一个或多个频道以接收那里发布的消息。
- **频道 (Channel)**: 是消息传递的媒介。发布者将消息发布到特定的频道，而订阅了该频道的所有订阅者都会收到该消息。

例如，假设我们有一个名为"news"的频道。一个发布者可以发布一条新闻到这个频道，而所有订阅了"news"频道的订阅者都会立即收到这条新闻。

在Redis中，您可以使用以下命令进行发布和订阅操作：

- `PUBLISH channel message`: 在指定的`channel`上发布一个`message`。
- `SUBSCRIBE channel`: 订阅指定的`channel`，以接收发布到该频道的消息。
- `UNSUBSCRIBE channel`: 取消订阅指定的`channel`。
- `PSUBSCRIBE pattern`: 使用模式匹配来订阅多个频道。

发布/订阅模式在Redis中常用于实时消息系统、日志收集、实时分析等场景。

当我们在配置中看到与"pubsub"相关的设置时，它是指与发布/订阅模式相关的客户端的设置，即那些订阅了频道并等待接收消息的客户端。