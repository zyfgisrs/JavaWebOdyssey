# Redis线程模型

## 目录

- [线程模型简述](#[线程模型简述)
- [Redis使用的是单线程还是多线程？](#Redis使用的是单线程还是多线程？)
- [Redis为什么这么快](#Redis为什么这么快)
- [Redis中的IO多路复用](#Redis中的IO多路复用)
- [Redis为什么这么快](#Redis为什么这么快)
- [Redis中IO线程的相关配置](#Redis中IO线程的相关配置)

## 线程模型简述

1. **单线程模型**：
   Redis 主要在一个单线程中执行所有命令。这意味着在任何给定的时刻，Redis 只在一个操作上工作。由于 Redis 主要存储在内存中，这使得其大部分操作非常快，并且没有并发和锁定的开销。

   单线程模型简化了数据结构的设计和实现，消除了大部分并发错误，并且在高吞吐量下仍然能够提供出色的性能。由于没有多线程的竞态条件和上下文切换，单线程可以快速地处理大量的请求。

2. **IO 多路复用**：
   虽然 Redis 的核心执行模型是单线程的，但它使用了 IO 多路复用技术，这使得它可以同时监听和服务多个客户端连接。

3. **部分多线程**：
   在 Redis 6.0 之后，尽管命令处理仍然是单线程的，但某些背景任务和网络 IO 任务已经支持多线程。例如，接受客户端连接、关闭客户端连接以及回复客户端请求这些网络操作可以使用多线程进行处理。这使得 Redis 在多核心 CPU 的现代硬件上能够更好地利用资源。

总结：Redis 主要采用单线程模型来处理命令，但它的 IO 操作和部分背景任务可以利用多线程，特别是在 Redis 6.0 及之后的版本中。/

## Redis使用的是单线程还是多线程？

1. **命令执行**：Redis 的主要命令执行引擎是单线程的。这意味着命令（如 SET、GET、INCR 等）在任何给定的时刻都是串行执行的。由于 Redis 主要在内存中操作并且数据结构高度优化，即使是单线程，它也能达到高达十万或百万次的操作每秒。
2. **网络 I/O**：尽管命令执行是单线程的，但 Redis 使用 IO 多路复用技术来同时处理多个客户端连接。这意味着单个 Redis 服务器可以处理多个并发客户端连接。（提升网络性能）
3. **多线程的部分**：从 Redis 6.0 开始，Redis 引入了线程化的 I/O。这意味着当执行与网络相关的任务（例如接收请求、发送响应等）时，Redis 可以使用多个线程。但这些线程仅用于处理网络 I/O，不会涉及到数据的实际处理或命令执行。
4. **背景任务**：一些背景任务，如持久化（RDB/AOF）和某些清理任务，是在单独的进程或线程中执行的，与主命令处理线程分开。

总结：虽然 Redis 的核心命令处理是单线程的，但在网络 I/O 和某些背景任务上，它确实利用了多线程或多进程。当我们说“Redis 是单线程的”时，我们主要指的是其命令执行模型。但从整体上看，Redis 在某些场景和操作中确实使用了多线程技术

## Redis为什么这么快

Redis 之所以如此快速，主要归因于它的设计决策、数据结构和运行环境。以下是全面回答这个问题的几个关键点：

1. **基于内存操作**：
   - Redis 是一个内存数据库，意味着大部分读写操作都直接在内存中进行，而内存的访问速度远远超过磁盘。
   - 使用内存可以避免磁盘 I/O 的延迟，这使得 Redis 可以快速响应。
2. **优化的数据结构**：
   - Redis 使用高度优化的数据结构，如哈希表、跳跃列表等，以提供快速的访问时间。
   - 数据结构的选择和实现方式确保了数据存取的高效性。
3. **单线程命令处理**：
   - Redis 的命令处理是单线程的，这消除了多线程环境中的锁开销、上下文切换和资源竞争。
   - 即使是单线程，Redis 也能够处理大量的请求，达到十万或百万次操作每秒。
4. **I/O 多路复用**：
   - Redis 使用 I/O 多路复用技术，能够在单线程中处理多个并发客户端连接。
   - 这允许 Redis 高效地接受、读取和响应来自多个客户端的请求。
5. **持久化策略**：
   - Redis 提供了多种持久化选项，如 RDB 快照和 AOF 日志。用户可以根据需要调整持久化策略以优化性能。
   - 例如，禁用持久化或使用间隔性的 RDB 持久化可以进一步提高性能。
6. **高效的网络协议**：
   - Redis 使用简单的文本协议 RESP (Redis Serialization Protocol) 进行通信，该协议设计简单、解析迅速。
7. **独立的子进程执行背景任务**：
   - 对于可能影响性能的操作，如持久化、数据压缩和其他清理任务，Redis 使用独立的子进程进行，确保主线程始终可用于命令处理。

## Redis中的IO多路复用

Redis 使用 I/O 多路复用来实现高性能的网络通信，以便在单线程中高效地处理大量并发客户端连接。以下是关于 Redis 中 I/O 多路复用的简述：

1. **作用**：Redis 使用 I/O 多路复用技术来同时监听多个 socket，以判断哪个 socket 准备好进行读或写。这允许 Redis 在一个线程中非阻塞地接受多个连接请求、读取请求或发送响应。

2. **实现方式**：Redis 可以配置使用不同的 I/O 多路复用技术，如 `select`, `poll`, `epoll`, `kqueue` 等。默认情况下，Redis 会选择最佳的、在当前平台上可用的多路复用库。

3. **事件循环**：Redis 主线程运行一个事件循环（event loop），检查文件描述符（通常是网络 sockets）是否准备好进行 I/O 操作。当一个或多个文件描述符准备好时，相应的操作（读、写、接受连接等）会被执行。

4. **优势**：使用 I/O 多路复用技术，Redis 可以非常高效地处理大量的并发客户端连接，而不需要为每个连接启动新的线程或进程。这大大减少了上下文切换的开销，并提高了 Redis 的性能和响应能力。

5. **与单线程模型的结合**：尽管 Redis 使用了 I/O 多路复用来处理网络事件，但其命令的处理和执行仍然是单线程的。这意味着网络事件和命令执行被序列化，避免了多线程或多进程环境中的锁、竞争条件等问题。

总之，Redis 中的 I/O 多路复用技术允许其在单一线程内高效地处理数千个并发客户端连接，确保即使在高并发条件下也能实现快速响应和高吞吐量。

## Redis中IO线程的相关配置

| 配置项                  | 描述                                 |
| ----------------------- | ------------------------------------ |
| io-threads 4            | 当前服务器的CPU为4核4线程            |
| io-threads-do-reads yes | 在进行数据读取阶段的时候使用工作线程 |

启动redis服务器查看redis的线程数

```
redis-server /usr/local/redis/conf/redis.cong
```

redis线程数显示

```
├─redis-server,1649
│   ├─{redis-server},1650
│   ├─{redis-server},1651
│   ├─{redis-server},1652
│   └─{redis-server},1653
```

这个时候主进程下面实际上由4个线程，其中一个为redis的主线程，对外直接提供服务，除了这一操作之后还会存在有AOF磁盘同步、关闭文件描述符以及惰性删除三个附加的子线程。

修改配置：

```
io-threads 4
io-threads-do-reads yes
```

重启redis服务器：

```
kill -9 1649
redis-server /usr/local/redis/conf/redis.conf
```

查看线程数：

```
pstree -apnh
```

显示：

```
  └─redis-server,1694
      ├─{redis-server},1695
      ├─{redis-server},1696
      ├─{redis-server},1697
      ├─{redis-server},1698
      ├─{redis-server},1699
      ├─{redis-server},1700
      ├─{redis-server},1701
      └─{redis-server},1702
```

可以看到，redis的主进程中多了三个用于用于网络请求接收的线程。