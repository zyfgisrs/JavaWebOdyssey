# Redis 位图功能

## 目录
1. [Redis 的位图功能简介](#redis-的位图功能简介)
2. [基础知识](#基础知识)
   - [位操作的基本概念](#位操作的基本概念)
   - [Redis 字符串的内部结构](#redis-字符串的内部结构)
3. [位操作命令](#位操作命令)
   - [`SETBIT`: 设置或清除指定偏移量的位(bit)](#setbit-设置或清除指定偏移量的位bit)
   - [`GETBIT`: 获取指定偏移量的位值](#getbit-获取指定偏移量的位值)
   - [`BITCOUNT`: 计算被设置为 1 的位数](#bitcount-计算被设置为-1-的位数)
   - [`BITOP`: 进行与、或、非、异或等位操作](#bitop-进行与或非异或等位操作)
4. [优势与限制](#优势与限制)

---

## Redis 的位图功能简介

Redis 的位图功能并不是一个真正的数据类型，而是一组定义在字符串数据类型上的位操作。

- 位图的大小是动态的，它会根据需要自动增长。但是，如果设置一个非常大的偏移量，Redis 可能需要分配大量内存，这可能会暂时阻塞服务器。
- 位图不是真正的数据类型，而是定义在字符串上的一组操作。这意味着可以使用其他字符串命令（如 `GET` 和 `SET`）来操作位图。

## 基础知识

### 位操作的基本概念

在计算机中，位（bit）是信息的最小单位，它只有两个可能的值，即 0 或 1。位操作是对单个或多个位进行的计算操作。主要的位操作包括：

- **AND**（与）：两个位都为1时，结果为1，否则为0。
- **OR**（或）：两个位之中至少有一个为1时，结果为1，否则为0。
- **XOR**（异或）：两个位不同时，结果为1，否则为0。
- **NOT**（非）：位值为1时，结果为0，反之为1。

### Redis 字符串的内部结构

Redis 的字符串类型（也称为 SDS, Simple Dynamic String）并不仅仅是为了存储常规的字符串，它也可以存储二进制数据，如图片、视频或序列化的对象。因此，其实 Redis 字符串更像一个字节数组。

以下是 Redis 字符串的主要特性和内部结构：

- **长度属性**：SDS 使用一个 header，其中包含了字符串的长度。这使得获取字符串长度的操作是 O(1) 的。
- **动态内存分配**：SDS 会根据实际的字符串长度动态地分配内存，避免浪费。
- **预分配空间**：当字符串被修改时，SDS 可能会分配比实际需要更多的内存，预留下一些额外空间来满足将来可能的需求，这有助于减少后续的内存重新分配操作。
- **二进制安全**：由于 SDS 存储的长度信息，它可以安全地保存包含零字节（'\0'）的二进制数据。
- **空终止**：尽管 SDS 可以保存二进制数据，但它总是在数据末尾维护一个空终止符（'\0'），这意味着 SDS 可以与常规的 C 字符串库函数互操作。
- **结构**：C 结构 `sdshdr` 在 sds.h 中声明，代表一个 Redis 字符串。它包含三个字段：`len`、`free` 和 `buf`。其中，`buf` 字符数组存储实际的字符串。

当我们谈论 Redis 的位操作时，我们实际上是在操作存储在 SDS 中的这些字节。例如，使用 `SETBIT` 和 `GETBIT` 可以设置或查询 SDS 中特定位置的位。

## 位操作命令

### `SETBIT`: 设置或清除指定偏移量的位(bit)

命令格式：

```
SETBIT key offset value
```

`SETBIT` 是一个 Redis 命令，用于设置或清除存储在特定键的字符串值中的某个位：

1. **基本操作**：`SETBIT` 可以设置或清除存储在特定键的字符串值中的某个位。
2. **位的位置和值**：您可以指定位的位置（称为偏移量）和值（0 或 1）。如果值是 1，那么该位将被设置；如果值是 0，那么该位将被清除。
3. **新建键**：如果指定的键不存在，Redis 会创建一个新的字符串值。
4. **字符串扩展**：如果需要，字符串会自动扩展以确保它可以容纳指定的偏移量。新增的位默认为 0。
5. **偏移量限制**：偏移量必须大于或等于 0 且小于 2^32。这意味着位图的最大大小为 512MB。
6. **内存分配警告**：当设置最后一个可能的位（偏移量等于 2^32 -1）并且该键还没有存储字符串值时，Redis 需要分配所有中间的内存，这可能会暂时阻塞服务器。
7. **返回值**：该命令返回存储在指定偏移量的原始位值。

案例：

假设我们正在

运行一个在线平台，我们想要跟踪每个用户每天的登录活动。我们可以使用 Redis 的位图功能来实现这一点，其中每个位代表一天。

当用户在某一天登录时，我们可以使用 `SETBIT` 来设置那一天的位。例如，如果用户在第 10 天和第 15 天登录，我们可以执行以下命令：

```
SETBIT user:1234:logins 10 1
SETBIT user:1234:logins 15 1
```

此时的位图为`0000000000100001`

要检查用户在第 10 天是否登录，我们可以使用 `GETBIT` 命令：

```
GETBIT user:1234:logins 10
(integer) 1
```

返回值为1，表明用户在第十天登录

统计用户一共登录的天数我们可以使用`BITCOUNT`命令：

```
BITCOUNT user:1234:logins
(integer) 2
```

返回值为2，因此用户一共登录了2天。

如果我们只想跟踪最近 365 天的数据，我们可以在第 366 天使用 `SETBIT` 将第 1 天的数据设置为 0：

```
SETBIT user:1234:logins 1 0
```

### `GETBIT`: 获取指定偏移量的位值

### `BITCOUNT`: 计算被设置为 1 的位数

### `BITOP`: 进行与、或、非、异或等位操作

`BITOP` 是一个 Redis 命令，用于在多个键（包含字符串值）之间执行按位操作，并将结果存储在目标键中。以下是 `BITOP` 的核心内容：

1. **支持的操作**：
   - `BITOP` 支持四种按位操作：AND、OR、XOR 和 NOT。
   - 有效的调用形式包括：
     - `BITOP AND destkey srckey1 srckey2 ... srckeyN`
     - `BITOP OR destkey srckey1 srckey2 ... srckeyN`
     - `BITOP XOR destkey srckey1 srckey2 ... srckeyN`
     - `BITOP NOT destkey srckey`（NOT 操作是特殊的，因为它只接受一个输入键，它执行位的反转，所以它只作为一元操作符有意义）。
2. **处理不同长度的字符串**：
   - 当在长度不同的字符串之间执行操作时，所有比集合中最长字符串短的字符串都被视为在最长字符串的长度上进行了零填充。
   - 对于不存在的键，它们被视为一串零字节，直到最长字符串的长度。
3. **返回值**：
   - 返回整数回复，表示存储在目标键中的字符串的大小，这等于最长输入字符串的大小。
4. **性能考虑**：
   - `BITOP` 是一个潜在的慢命令，因为它的运行时间是 O(N)。
   - 当对长输入字符串运行时，应该小心。对于涉及大输入的实时指标和统计，一个好的方法是在副本上执行按位操作，以避免阻塞主实例。

案例：

```
redis-server:6379> SET key1 "foobar"
OK
redis-server:6379> SET key2 "abcdef"
OK
redis-server:6379> BITOP AND dest key1 key2
(integer) 6
redis-server:6379> GET dest
"`bc`ab"
```

解释：

- 第一个字符：`f` 的 ASCII 值是 102，其二进制表示是 `01100110`；`a` 的 ASCII 值是 97，其二进制表示是 `01100001`。进行按位与操作后，我们得到 `01100000`，这是 ASCII 值 96，对应的字符是 ```。
- 第二个字符：`o` 的 ASCII 值是 111，其二进制表示是 `01101111`；`b` 的 ASCII 值是 98，其二进制表示是 `01100010`。进行按位与操作后，我们得到 `01100010`，这是 ASCII 值 98，对应的字符是 `b`。
- 第三个字符：`o` 的 ASCII 值是 111，其二进制表示是 `01101111`；`c` 的 ASCII 值是 99，其二进制表示是 `01100011`。进行按位与操作后，我们得到 `01100011`，这是 ASCII 值 99，对应的字符是 `c`。
- 第四个字符：`b` 的 ASCII 值是 98，其二进制表示是 `01100010`；`d` 的 ASCII 值是 100，其二进制表示是 `01100100`。进行按位与操作后，我们得到 `01100000`，这是 ASCII 值 96，对应的字符是 ```。
- 第五个字符：`a` 的 ASCII 值是 97，其二进制表示是 `01100001`；`e` 的 ASCII 值是 101，其二进制表示是 `01100101`。进行按位与操作后，我们得到 `01100001`，这是 ASCII 值 97，对应的字符是 `a`。
- 第六个字符：`r` 的 ASCII 值是 114，其二进制表示是 `01110010`；`f` 的 ASCII 值是 102，其二进制表示是 `01100110`。进行按位与操作后，我们得到 `01100010`，这是 ASCII 值 98，对应的字符是 `b`。

案例：

```
redis-server:6379> SET key3 abc
OK
redis-server:6379> SET key4 1234
OK
redis-server:6379> BITOP OR dests key3 key4
(integer) 4
redis-server:6379> GET dests
"qrs4"
```

- 第一个字符：`a` 的 ASCII 值是 141，其二进制表示是 `0110 0001`；`1` 的 ASCII 值是 61，其二进制表示是 `0011 0001`。进行按位或操作后，我们得到 `0111 0001`，这是 ASCII 值 113，对应的字符是 `q`。

- …..
- 第四个字符：为空使用 `00000000`填充；`4` 的 ASCII 值是 64，其二进制表示是 `0011 0100`。进行按位与操作后，我们得到 `0011 0100`，这是 ASCII 值 64，对应的字符是 `4`。

## 优势与限制

- 优势：高效的内存使用，快速的统计和查询
- 限制：固定的大小（2^32 - 1）

---

希望这种排版能满足您的需求！如果有任何其他要求或问题，请告诉我。